# v_kernel 최종 분석 리포트

## 요약

**결론: v_kernel=30이 최적값**

세 가지 v_kernel 값(30, 35, 50)을 비교한 결과, **v_kernel=30**이 가장 우수한 성능을 보였습니다.

---

## 1. 비교 결과

### 검출 성능 비교

| 항목 | v=30 | v=35 | v=50 | 비고 |
|------|------|------|------|------|
| 총 연결 요소 | 266 | 237 (-10.9%) | 142 (-46.6%) | v=30 기준 |
| 세로 블록 (필터 후) | 49 | 44 (-10.2%) | 26 (-46.9%) | aspect < 0.5 |
| **인테그랄 후보** | **7** | **6 (-14.3%)** | **6 (-14.3%)** | **aspect < 0.2** |

### 인테그랄 크기 분포

| 항목 | v=30 | v=35 | v=50 |
|------|------|------|------|
| 평균 높이 | **106.1px** | 85.0px ↓ | 103.3px |
| 높이 범위 | 15-158px | 15-150px | 15-156px |
| 평균 너비 | 16.9px | 13.8px | 14.8px |

---

## 2. v_kernel=35/50의 문제점

### 과도한 병합 (Over-merging)

#### v_kernel=35
- 세로 블록 **-10.2% 감소** (49 → 44개)
- 인테그랄 후보 **-14.3% 감소** (7 → 6개) ❌
- 평균 인테그랄 높이 **-20% 감소** (106.1px → 85.0px) ❌

#### v_kernel=50
- 세로 블록 **-46.9% 감소** (49 → 26개) ❌❌
- 총 블록 수 **-46.6% 감소** (266 → 142개) ❌❌
- **심각한 부작용**: 작은 세로 블록들이 주변 텍스트와 병합되어 소실됨

### 병합 메커니즘

v_kernel이 클수록:
1. 세로 방향으로 멀리 떨어진 픽셀들도 연결됨
2. 인테그랄 조각뿐만 아니라 **무관한 텍스트 블록**도 함께 병합됨
3. 결과적으로 세로 블록 수가 감소하고, 일부 인테그랄 후보가 소실됨

---

## 3. v_kernel=30에서의 인테그랄 잘림 문제

### 잘림 현황

`diagnose_integral_truncation.py` 분석 결과:
- **11개 인테그랄 후보 중 10개가 위아래 잘림**

주요 사례:
- Block 660: 위쪽 57px 확장 가능 (검은 픽셀 47개)
- Block 661: 위쪽 58px 확장 가능 (검은 픽셀 51개)
- Block 227: 위쪽 7px 확장 가능
- Block 152: 아래쪽 9px 확장 가능

### 잘림 원인

1. **근처 블록이 인테그랄 조각이 아님**
   - Block 152 아래: 4개 근처 블록 (Y_gap 73-82px)
   - Block 660 위: 7개 근처 블록 (Y_gap 28-98px)
   - **이들은 일반 텍스트 블록** (aspect > 0.5, width > 30px)

2. **인테그랄 상/하단 곡선이 별도 검출되지 않음**
   - 너무 작거나 가로로 넓어서 vertical_tall 필터를 통과하지 못함
   - aspect ratio가 0.5 이상이거나 height < 10px

3. **gap이 max_gap(100px)을 초과**
   - 일부 블록 간 gap이 73-98px로 근접하지만, 다른 조건(X 좌표, aspect ratio)을 만족하지 못함

### 왜 v_kernel 증가로 해결되지 않는가?

만약 v_kernel=77 (58 + 9 + margin)로 증가하면:
- v_kernel=50에서 이미 -46.9% 블록 감소
- v_kernel=77은 **더 심각한 과도 병합 발생 예상** (-70% 이상?)
- 인테그랄 검출은 개선되지 않음 (v=50도 6개로 v=35와 동일)

**v_kernel=50 vs v=35 비교에서 인테그랄 개수가 동일(6개)**한 것은, v_kernel 증가가 인테그랄 검출에 도움이 되지 않음을 의미합니다.

---

## 4. Trade-off 분석

### v_kernel=30의 장점
- ✅ **가장 많은 인테그랄 후보 검출** (7개)
- ✅ 세로 블록 수 안정적 유지 (49개)
- ✅ 부작용 없음 (과도 병합 없음)
- ✅ 평균 인테그랄 높이가 가장 큼 (106.1px)

### v_kernel=30의 단점
- ❌ 일부 인테그랄 위아래 잘림 (10/11개)
- ❌ 평균 잘림: 위 10px, 아래 2px 정도

### 트레이드오프
| v_kernel | 인테그랄 개수 | 인테그랄 완전도 | 부작용 |
|----------|---------------|-----------------|--------|
| 30 | 7개 ✅ | 위아래 약간 잘림 | 없음 ✅ |
| 35 | 6개 ❌ | 여전히 잘림 | 블록 -10% ⚠️ |
| 50 | 6개 ❌ | 여전히 잘림 | 블록 -47% ❌❌ |

**결론**: v_kernel 증가는 인테그랄 완전도를 개선하지 못하면서 심각한 부작용만 유발합니다.

---

## 5. 대안 접근법 (향후 개선 방안)

v_kernel 증가 대신 다음 방법들을 고려할 수 있습니다:

### A. 후처리 병합 로직 강화
현재 `_merge_vertical_fragments()`는 세로 블록만 병합합니다.
- **개선**: 세로 블록과 근처의 작은 가로 블록도 조건부 병합
- 조건: Y 간격 < 20px, X 겹침, 가로 블록 크기 < 50px

### B. 초기 검출 강화
현재 5개 스케일로 검출하지만, 인테그랄 상/하단 곡선을 놓칠 수 있습니다.
- **개선**: "인테그랄 끝부분" 전용 스케일 추가
- 예: `{"name": "integral_ends", "h_kernel": 8, "v_kernel": 5, "min_size": 20}`

### C. 밀도 기반 병합
픽셀 밀도 분석을 사용하여 인테그랄 블록 주변의 약한 픽셀들도 포함
- 현재 블록 bbox 주변 ±20px 영역의 픽셀 밀도 확인
- 밀도 > 0.1이면 bbox 확장

### D. 머신러닝 기반 후처리
(장기 계획)
- 학습된 모델을 사용하여 "잘린 인테그랄" 패턴 인식
- 자동으로 bbox 확장 제안

---

## 6. 최종 권장 사항

### 즉시 적용
✅ **v_kernel=30으로 복원**

이유:
1. 가장 많은 인테그랄 후보 (7개) 검출
2. 부작용 없음 (블록 수 안정적)
3. v_kernel 증가는 검출 개선 없이 부작용만 유발

### 잘림 문제 대응
현재 v_kernel=30에서의 인테그랄 잘림은:
- 평균 위쪽 10px, 아래쪽 2px 정도
- **사용 목적에 따라 수용 가능한 수준일 수 있음**

만약 완전한 인테그랄이 필수적이라면:
- v_kernel 증가가 아닌 **후처리 병합 로직 강화** 권장 (위 5-A 참조)

---

## 7. 코드 변경 사항

### 복원할 설정 (`multiscale_analyzer.py`)

```python
# Line 37
{"name": "vertical_tall", "h_kernel": 3, "v_kernel": 30, "min_size": 100},
```

현재:
- ❌ v_kernel=35 (인테그랄 7→6개로 감소, 블록 -10%)

복원 후:
- ✅ v_kernel=30 (인테그랄 7개, 부작용 없음)

---

## 8. 결론

### 핵심 발견
1. v_kernel=30이 최적값 (인테그랄 7개, 부작용 없음)
2. v_kernel=35는 인테그랄 -14.3%, 블록 -10.2% 감소 (부정적)
3. v_kernel=50은 심각한 과도 병합 (블록 -47%)

### 권장 조치
✅ **v_kernel=30으로 복원**

### 향후 개선
인테그랄 완전도 향상이 필요하다면:
- 후처리 병합 로직 강화 (방법 5-A)
- 초기 검출 스케일 추가 (방법 5-B)

**v_kernel 증가는 효과 없음 + 부작용 심각**

---

*분석 일시: 2025-11-16*
*테스트 이미지: page_0000.png*
*비교 스크립트: compare_three_v_kernels.py*
