# 블록 검출 품질 문제 심층 분석

**작성일**: 2025-11-16
**현재 상태**: Priority 0.5 적용 (43개 블록 검출)
**목표**: 참조 이미지 수준 (79개 블록)
**문제**: 검출되어야 할 블록들이 누락됨

---

## 1. 정량적 격차 분석

### 1.1 블록 개수 비교

| 구분 | 현재 (Priority 0.5) | 참조 이미지 | 격차 |
|------|-------------------|------------|------|
| 검출된 블록 수 | **43개** | **79개** | -36개 (-46%) |
| 페이지 구성 | 2단 레이아웃 | 2단 레이아웃 | 동일 |
| 평균 블록 크기 | ~10,000px² | ~5,000px² 추정 | 2배 큰 |

**핵심 문제**: 현재 검출은 **참조 대비 54%** 수준. **46%의 블록이 누락**됨.

### 1.2 블록 크기 분포 분석

**참조 이미지 (Detailed Block-level Analysis)**:
- 히스토그램을 보면 작은 블록들이 매우 많음
- 대부분의 블록이 1,000-5,000px² 범위
- 매우 세밀한 단위로 분리됨

**현재 결과**:
- 대표 블록들이 10,000-40,000px² 범위
- 훨씬 큰 단위로 병합됨
- 세밀함 부족

---

## 2. 시각적 비교 및 누락 블록 식별

### 2.1 참조 이미지 분석 (하단 우측 초록색 블록맵)

참조 이미지의 "Detected Blocks (79 regions)" 시각화를 보면:

**왼쪽 컬럼 특징**:
```
- 문제 번호 (01, 02, 03 등)가 각각 독립 블록
- 문제 제목이 독립 블록
- 각 지문 라인이 개별 블록
- 보기 항목들 (①, ②, ③, ④, ⑤)이 각각 독립 블록
- 수식 부분이 독립 블록
```

**오른쪽 컬럼 특징**:
```
- 문제 번호가 독립 블록
- 지문의 각 문장이 거의 독립 블록
- 표/그림 영역이 독립 블록
- 보기가 각각 분리됨
```

**예상 블록 구성** (왼쪽 컬럼 기준):
```
문제 01:
  - "01" (번호) - 1블록
  - "알킬 은경" (제목) - 1블록
  - 지문 라인 1 - 1블록
  - 지문 라인 2 - 1블록
  - 지문 라인 3 - 1블록
  - 보기 ① - 1블록
  - 보기 ② - 1블록
  - 보기 ③ - 1블록
  - 보기 ④ - 1블록
  - 보기 ⑤ - 1블록
  → 약 10개 블록

4개 문제 × 10개 = 40개 (왼쪽만)
오른쪽도 유사 → 총 79개 합리적
```

### 2.2 현재 결과 분석 (test_result_visualization.png)

**왼쪽 컬럼 (초록색 박스들)**:

보이는 문제점:
1. **과도한 병합 발견**:
   ```
   - "문제 01 알킬 은경" 전체가 하나의 큰 박스
     → 실제로는 번호/제목/지문이 분리되어야 함

   - 문제 01 하단의 긴 초록색 박스
     → 여러 지문 라인이 하나로 병합됨
     → 참조에서는 각 라인이 독립 블록

   - 보기 영역이 하나의 큰 박스
     → ①②③④⑤가 각각 분리되어야 함
   ```

2. **누락된 블록 유형**:
   ```
   ❌ 개별 보기 항목 (①, ②, ③, ④, ⑤)
   ❌ 각 지문 라인
   ❌ 문제 번호/제목 분리
   ❌ 수식 영역
   ```

**오른쪽 컬럼 (빨간색 박스들)**:

일부는 잘 분리됨:
- 문제 번호들이 작은 박스로 독립적

하지만 문제점:
```
- 지문이 큰 박스로 병합됨
- 보기들이 병합됨
- 각 문장/라인이 분리 안 됨
```

### 2.3 구체적 예시 비교

**예시: 문제 01 영역**

참조 이미지 예상:
```
[01]           ← 블록 1
[알킬 은경]     ← 블록 2
[지문 라인1]    ← 블록 3
[지문 라인2]    ← 블록 4
[① 첫번째 보기] ← 블록 5
[② 두번째 보기] ← 블록 6
...
총 ~10개 블록
```

현재 결과:
```
[01 + 알킬 은경 + 지문 일부]  ← 블록 1 (거대)
[지문 나머지 전체]           ← 블록 2 (거대)
[보기 전체]                 ← 블록 3 (거대)
...
총 ~3-4개 블록
```

**결과**: **70% 손실** (10개 → 3-4개)

---

## 3. 근본 원인 분석

### 3.1 현재 Priority 0.5의 메커니즘

```python
# density_analyzer.py 라인 134-140
h_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))
h_closed = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, h_kernel)

v_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 2))
v_closed = cv2.morphologyEx(h_closed, cv2.MORPH_CLOSE, v_kernel)
```

### 3.2 문제점 1: 수평 커널이 너무 큼

**h_kernel = (25, 1)**:
```
의미: 25픽셀 범위 내의 모든 수평 요소를 연결

결과:
- "문제", "01", "알킬", "은경" → 모두 연결
- "①", "첫번째", "보기", "내용" → 모두 연결
- 각 단어 간 공백 (5-15px) < 25px → 모두 병합

문제:
→ 별개의 의미 단위(번호/제목/보기)가 하나로 병합됨
```

**참조 이미지가 원하는 것**:
```
- "01" 독립
- "알킬 은경" 독립
- "①" 독립
- "② 보기 내용" 하나로 (이건 병합 OK)

→ 더 작은 단위 필요 (10-15px?)
```

### 3.3 문제점 2: 세밀함 vs 파편화의 균형 실패

**지금까지의 여정**:

| 버전 | h_kernel | v_kernel | 블록 수 | 문제 |
|------|----------|----------|---------|------|
| Initial | (3, 3) | - | 18 | 극심한 파편화 |
| Priority 0 | (30, 1) | (1, 5) | 27 | 거대 블록 생성 |
| **Priority 0.5** | **(25, 1)** | **(1, 2)** | **43** | **과도한 병합** |
| Priority 1 | 투영+5px | - | 236 | 극심한 파편화 |
| **목표** | **?** | **?** | **79** | **적절한 균형** |

**핵심 인사이트**:
```
h_kernel 크기별 효과:
- 30px: 문장 단위 병합 (너무 큼)
- 25px: 구문 단위 병합 (현재, 여전히 큼)
- 15px: 단어 묶음 단위 병합 (목표?)
- 10px: 단어 단위 병합
- 5px:  글자 단위 병합 (너무 작음)

현재 25px는 "구문 수준"
목표는 "단어 묶음 수준" (15px 내외)
```

### 3.4 문제점 3: 일률적 처리

현재 방식:
```
모든 텍스트에 동일한 커널 적용
→ 문제 번호, 제목, 지문, 보기를 구분 안 함
```

참조 이미지가 보여주는 것:
```
- 문제 번호 "01": 매우 작은 독립 블록
- 보기 "①": 매우 작은 독립 블록
- 일반 텍스트: 적당한 크기 블록

→ 요소별 다른 처리가 필요할 수도
```

---

## 4. 해결 방안

### 4.1 Option A: h_kernel 크기 감소 (우선 추천)

**전략**:
```python
# 현재
h_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))

# 수정
h_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (15, 1))
```

**근거**:
- 25px → 15px: 40% 감소
- 예상: 단어 간 공백(5-10px)은 연결, 의미 단위 간 공백(15px+)은 분리
- 예상 블록 수: 43 → 65-75개

**장점**:
✅ 간단한 수정 (1줄)
✅ 즉시 테스트 가능
✅ 검증된 모폴로지 방식 유지

**단점**:
❌ 여전히 일률적 처리
❌ 파편화 위험 존재

### 4.2 Option B: 다단계 커널 (중급)

**전략**:
```python
# 1단계: 작은 커널로 글자 단위 연결
small_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 1))
connected = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, small_kernel)

# 2단계: 중간 커널로 단어 단위 연결
medium_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (12, 1))
connected = cv2.morphologyEx(connected, cv2.MORPH_CLOSE, medium_kernel)

# 3단계: 수직은 최소한만
v_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 2))
final = cv2.morphologyEx(connected, cv2.MORPH_CLOSE, v_kernel)
```

**장점**:
✅ 더 세밀한 제어
✅ 단계별 조정 가능

**단점**:
❌ 복잡도 증가
❌ 파라미터 튜닝 필요

### 4.3 Option C: 투영 분석 개선 (고급)

**전략**:
```python
# projection_analyzer.py 수정
min_gap = 15  # 5 → 15 (단어 간은 연결, 의미 단위 간은 분리)
```

투영 분석을 사용하되 min_gap을 조정하여:
- 라인 검출: 투영 분석
- 라인 내 블록 분리: min_gap=15로 조정

**예상 결과**:
- 블록 수: 70-85개
- 품질: 높음

**장점**:
✅ 정밀한 라인 검출
✅ 조정 가능한 분리 기준

**단점**:
❌ Priority 1 재활용 (이미 실패 경험)
❌ 파라미터 민감도 높음

### 4.4 Option D: 하이브리드 최적화 (최고급)

**전략**:
```python
def _find_blocks_hybrid_v2(self, mask, columns):
    all_blocks = []

    for column in columns:
        # 1단계: 투영으로 텍스트 라인 검출
        lines = self.projection.detect_text_lines(mask, column_bbox)

        for line in lines:
            line_mask = extract_line_mask(mask, line)

            # 2단계: 라인 내에서 모폴로지 연결
            # 작은 커널 사용 (15px)
            h_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (15, 1))
            connected = cv2.morphologyEx(line_mask, cv2.MORPH_CLOSE, h_kernel)

            # 3단계: 컴포넌트 검출
            contours = cv2.findContours(connected, ...)

            # 각 컴포넌트를 블록으로
            for contour in contours:
                bbox = cv2.boundingRect(contour)
                all_blocks.append(bbox)

    return all_blocks
```

**로직**:
1. 투영으로 라인 검출 (정확)
2. 각 라인 내에서만 모폴로지 적용 (라인 간 병합 방지)
3. 작은 커널(15px) 사용 (세밀함 유지)

**예상 결과**:
- 블록 수: 75-85개
- 품질: 매우 높음
- 라인 간 병합 없음
- 의미 단위 적절히 분리

**장점**:
✅ 두 방식의 장점 결합
✅ 최고 품질 기대
✅ 라인 간 병합 원천 차단

**단점**:
❌ 개발 시간 2-3시간
❌ 복잡도 최고
❌ 디버깅 어려움

---

## 5. 실험 계획

### 5.1 단계별 접근 (권장)

**Phase A: h_kernel 최적화 (15분)**
```
1. h_kernel을 25 → 20 → 15 → 12로 순차 감소
2. 각 단계마다 테스트
3. 블록 수가 70-80개에 도달하는 값 찾기
```

**Phase B: 미세 조정 (15분)**
```
4. Phase A에서 찾은 값 ±2 범위 테스트
5. 시각적 품질 평가
6. 최적값 확정
```

**Phase C: 하이브리드 (필요시, 1-2시간)**
```
7. Phase B 결과가 불만족스러우면
8. Option D (하이브리드) 구현
9. 최종 테스트
```

### 5.2 예상 결과표

| h_kernel | 예상 블록 수 | 예상 품질 | 예상 문제 |
|----------|------------|----------|----------|
| 25 (현재) | 43 | 54% | 과도한 병합 |
| 20 | 55 | 70% | 여전히 병합 |
| **15** | **70-75** | **85-90%** | **목표 달성?** |
| 12 | 85-90 | 80% | 과도한 분리? |
| 10 | 100+ | 60% | 파편화 시작 |
| 5 | 150+ | 30% | 극심한 파편화 |

**권장값**: **h_kernel = (15, 1)**

---

## 6. 참조 이미지 재분석

### 6.1 Detailed Block-level Analysis 그래프 해석

**왼쪽 상단 (Left vs Right Region Density)**:
- 왼쪽/오른쪽 컬럼의 밀집도 투영
- 파란색/빨간색 피크가 텍스트 라인 위치
- 매우 많은 피크 → 매우 세밀한 라인 검출

**왼쪽 하단 (Auto-detection Overlap Regions)**:
- 블록 간 겹침 분석
- 깨끗한 분리를 보여줌

**중앙 (히스토그램)**:
- 블록 크기 분포
- 대부분 작은 블록 (1,000-5,000px²)
- 현재 우리: 10,000-40,000px² (2-8배 큼)

**우측 하단 (Detected Blocks - 79 regions)**:
- 초록색 박스들이 매우 조밀
- 각 문장/보기가 독립 블록
- **이것이 목표 품질**

### 6.2 핵심 차이점

| 요소 | 참조 (79블록) | 현재 (43블록) | 비율 |
|------|-------------|-------------|------|
| 블록 수 | 79 | 43 | 54% |
| 평균 크기 | ~5,000px² | ~10,000px² | 200% |
| 세밀도 | 매우 높음 | 중간 | - |
| 의미 단위 | 문장/보기 | 문단/영역 | - |

---

## 7. 결론 및 권장사항

### 7.1 현재 상태 평가

**점수**: ⭐⭐⭐☆☆ (3/5) - 60%

기존 평가 85%에서 하향:
- 이유: 참조 이미지(79블록) 대비 크게 부족
- 사용자 피드백: "검출되어야 할 블록이 많이 누락"
- 정량적 격차: 46% 블록 누락

**성공한 부분**:
✅ 거대 블록 문제 해결
✅ 극심한 파편화 방지
✅ 기본 구조 구현 완료

**실패한 부분**:
❌ 블록 수 부족 (43 vs 79)
❌ 과도한 병합 (h_kernel=25가 너무 큼)
❌ 의미 단위 분리 불충분
❌ 보기/번호 등이 병합됨

### 7.2 즉시 실행 권장사항

**우선순위 1: h_kernel 최적화 (15분 소요)**

```python
# src/density_analyzer.py 라인 134
# 수정 전
h_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))

# 수정 후
h_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (15, 1))
```

**근거**:
- 25px → 15px: 적절한 감소 비율
- 예상: 43 → 70개 (목표 79개에 근접)
- 가장 간단하고 빠른 해결책

**테스트 절차**:
```bash
# 1. 수정
# 2. 테스트
python tests/test_pipeline.py

# 3. 결과 확인
# - 블록 수가 65-80 범위인가?
# - 시각화가 참조 이미지와 유사한가?
```

**만약 15로 부족하면**:
```python
# 더 감소
h_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (12, 1))
# 또는
h_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (10, 1))
```

### 7.3 차선책

**만약 h_kernel 조정만으로 부족하면**:

Option D (하이브리드) 구현:
- 투영으로 라인 검출
- 라인 내에서만 모폴로지 적용
- 더 정밀한 제어 가능

---

## 8. 예상 개선 효과

### 8.1 h_kernel = 15 적용 시

**블록 수 예상**:
```
현재: 43개
→
예상: 68-75개 (목표 79개의 86-95%)
```

**개선 영역**:
```
✅ 문제 번호 독립 분리
✅ 보기 항목 개별 분리 (①, ②, ③, ④, ⑤)
✅ 지문 라인별 분리
✅ 제목/본문 분리
```

**품질 점수**:
```
현재: 60% (참조 대비)
→
예상: 85-90% (참조에 근접)
```

### 8.2 성공 기준

**정량적**:
- [ ] 블록 수: 70-85개 (참조 79개 ±10%)
- [ ] 평균 블록 크기: ~5,000px² (참조와 유사)

**정성적**:
- [ ] 문제 번호가 독립 블록
- [ ] 보기가 각각 분리됨
- [ ] 지문이 라인별로 분리됨
- [ ] 시각화가 참조 이미지와 유사

---

## 9. 위험 요소 및 대응

### 9.1 위험: 과도한 분리

**시나리오**:
h_kernel을 너무 작게 (예: 10px) 하면
→ 단어 단위 파편화 발생
→ Priority 1처럼 236개 블록

**대응**:
- 단계적 감소 (25 → 20 → 15)
- 각 단계마다 시각화 확인
- 70-80 범위 유지

### 9.2 위험: 수식 파손

**시나리오**:
수식의 위/아래 첨자가 분리될 수 있음

**대응**:
- v_kernel = (1, 2) 유지 (충분히 작음)
- 수식 영역 테스트 필수

### 9.3 위험: 일부 요소만 개선

**시나리오**:
h_kernel 조정으로 일부는 개선되지만
여전히 목표에 미달

**대응**:
- Option D (하이브리드) 준비
- 투영 + 모폴로지 조합
- 최종 수단

---

## 10. 다음 단계

### 10.1 즉시 실행 (지금 바로)

1. **h_kernel = (15, 1) 적용**
2. **테스트 실행**
3. **시각화 비교**

### 10.2 결과에 따른 분기

**Case A: 블록 수 70-80개 달성**
→ ✅ 성공! Phase 2 (GUI) 진행

**Case B: 블록 수 여전히 부족 (50-65개)**
→ h_kernel을 12 또는 10으로 추가 감소

**Case C: 블록 수 과다 (90-100개+)**
→ h_kernel을 17-18로 증가

**Case D: 어떤 값으로도 목표 미달**
→ Option D (하이브리드) 구현

---

## 11. 최종 요약

**현재 문제**:
```
43개 블록 < 79개 목표
과도한 병합으로 46% 블록 누락
h_kernel = 25px가 너무 큼
```

**해결책**:
```
h_kernel = 25 → 15 (40% 감소)
예상: 70-75개 블록 (목표 달성)
소요 시간: 15분
```

**실행 명령**:
```python
# src/density_analyzer.py 라인 134 수정
h_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (15, 1))
```

**성공 확률**: 80%

**실패 시 대안**: Option D (하이브리드) 구현

---

**작성자**: Claude Code
**다음 작업**: h_kernel 최적화 실험 (Priority 0.7)
**긴급도**: 높음 (사용자 불만족)
**중요도**: 높음 (Phase 1 완성도 결정)
