

# **에이전틱 디자인 엔지니어링: '심플리시티(Simplicity)' 디자인 언어의 기술적 구현과 활용 전략 보고서**

## **1\. 서론: 디자인 철학과 에이전틱 엔지니어링의 융합**

현대 핀테크 및 슈퍼앱(Super App) 시장을 관통하는 가장 강력한 디자인 흐름은 '급진적인 단순함(Radical Simplicity)'입니다. 특히 토스(Toss)와 같은 선도적인 서비스들이 채택하고 있는 '심플리시티(Simplicity)' 디자인 언어는 단순한 시각적 미니멀리즘을 넘어, 사용자의 인지 부하를 최소화하고 금융과 같은 복잡한 맥락을 직관적인 '물리적 상호작용'으로 치환하는 고도화된 UX 방법론입니다. 이러한 디자인 언어는 굵고 명확한 타이포그래피(Pretendard), 선명한 컬러 이론(Vivid Blue & Cool Grey), 그리고 현실 세계의 물리 법칙을 모사한 유려한 모션(Physics-based Motion)을 핵심 축으로 삼습니다.1

그러나 이러한 고충실도(High-Fidelity)의 디자인 시스템을 실제 프로덕션 레벨에서 구현하고 유지보수하는 것은 막대한 엔지니어링 리소스를 요구합니다. 여기서 등장하는 것이 바로 앤스로픽(Anthropic)의 'Claude Code'와 같은 에이전틱(Agentic) AI 도구입니다. 이 보고서는 귀하가 조사한 '심플리시티' 디자인 언어의 미학적, 기능적 가치를 깊이 있게 분석하고, 이를 Next.js, Tailwind CSS, Framer Motion, Supabase로 구성된 현대적인 기술 스택 위에서 Claude Code CLI를 활용하여 효율적으로 구현하는 '방법론(How-to)'을 망라한 기술 실행 가이드입니다.4

본 보고서는 단순히 코드를 나열하는 것을 넘어, AI 에이전트를 '주니어 개발자'가 아닌 '디자인 시스템 아키텍트'로 활용하기 위한 컨텍스트 엔지니어링(Context Engineering) 기법을 중심으로 서술되었습니다. 우리는 이를 통해 디자인 언어의 일관성을 유지하면서도 개발 속도를 극대화하는 구체적인 실행 전략을 제시합니다.

---

## **2\. 디자인 철학의 해체: '심플리시티(Simplicity)'의 핵심 가치와 UX 언어**

기술적 구현에 앞서, 우리가 구현하고자 하는 디자인 언어의 본질을 이해하는 것이 필수적입니다. '심플리시티'는 장식적인 요소를 제거하고 본질적인 기능만을 남기는 '환원주의적(Reductive)' 접근 방식을 취합니다.

### **2.1 타이포그래피 중심의 위계 구조 (Typography-First Hierarchy)**

이 디자인 언어의 가장 큰 특징은 그래픽 요소(선, 면, 아이콘)에 의존하기보다, 글자의 크기, 두께, 색상만으로 정보의 위계를 설정한다는 점입니다. 이는 사용자가 콘텐츠 자체에 집중하게 만듭니다.

* **서체 선택:** 한국어와 영문 숫자의 조형적 통일성을 위해 'Pretendard' 가변 폰트(Variable Font)가 표준으로 사용됩니다. 이는 Apple의 San Francisco와 유사한 조형미를 가지면서도 웹 환경에서의 렌더링 최적화가 뛰어납니다.6  
* **위계 설정 전략:**  
  * **헤드라인:** 압도적인 크기와 Bold/ExtraBold 웨이트를 사용하여 화면의 목적을 즉시 전달합니다.  
  * **본문:** 가독성을 최우선으로 하며, 완전한 검정(\#000000)보다는 짙은 회색(Dark Grey)을 사용하여 눈의 피로도를 낮춥니다.  
  * **캡션:** 옅은 회색을 사용하되, 접근성(Accessibility)을 해치지 않는 명도 대비를 유지합니다.

### **2.2 인지적 명확성을 위한 컬러 시스템 (Cognitive Color Theory)**

색상은 단순한 심미적 요소를 넘어 기능을 수행하는 '신호'로 작용합니다.

| 색상 역할 (Role) | 특징 및 의도 (Characteristics & Intent) | 구현 목표 (Implementation Goal) |
| :---- | :---- | :---- |
| **Primary Blue** | 높은 채도와 명도를 가진 '비비드 블루'. 신뢰, 금융, 완료, 긍정을 상징하며 행동 유도(CTA) 버튼에 독점적으로 사용됩니다. | 기존의 칙칙한 기업용 파란색이 아닌, 디지털 스크린에서 발광하는 듯한 느낌을 주는 HSL 값을 설정해야 합니다.3 |
| **Cool Greys** | 파란색 틴트(Tint)가 아주 미세하게 섞인 회색. 차가운 디지털 환경에 어울리며, 세련된 느낌을 줍니다. | 웜 그레이(Warm Grey) 계열을 배제하고, 배경과 텍스트 사이의 명확한 레이어를 형성하기 위해 50\~900 단계의 스케일을 정교하게 조정합니다.9 |
| **System Colors** | 적색(에러/출금), 녹색(성공/입금) 등은 기존 관념을 따르되, 파스텔 톤보다는 명시성이 높은 채도를 유지합니다. | 기능적 의미 전달 실패를 방지하기 위해 엄격하게 통제된 토큰을 사용합니다. |

### **2.3 물리 법칙을 모사한 인터랙션 (Physics-Based Motion)**

'심플리시티' 경험의 핵심은 정적인 화면이 아니라 '살아있는 듯한 움직임'에 있습니다. iOS의 네이티브 앱 경험을 웹으로 이식하기 위해, 선형적인 애니메이션(Linear, Ease-in-out)을 배제하고 스프링(Spring) 물리학을 적용합니다.

* **텐션과 댐핑 (Tension & Damping):** 사용자의 터치나 마우스 인터랙션에 즉각 반응(High Stiffness)하되, 끝맛은 부드럽게 감속(Correct Damping)하는 모션 커브를 사용합니다.11  
* **마이크로 인터랙션:** 버튼을 누를 때 살짝 작아지는(Scale Down) 효과, 리스트가 나타날 때의 순차적 등장(Staggering) 등은 사용자가 시스템과 교감하고 있다는 피드백을 줍니다.

---

## **3\. 에이전틱 워크스페이스 구축: Claude Code CLI 컨텍스트 엔지니어링**

이러한 고도화된 디자인 언어를 일관성 있게 구현하기 위해서는 AI 에이전트(Claude)에게 프로젝트의 '법칙'을 명확히 주입해야 합니다. Claude Code CLI 도구는 터미널 환경에서 직접 파일 시스템을 조작하고 명령어를 실행할 수 있어, 디자인 시스템 구축의 강력한 파트너가 됩니다.13

### **3.1 CLAUDE.md: 디자인 헌법(Constitution) 정의**

CLAUDE.md 파일은 Claude가 프로젝트에 진입할 때마다 가장 먼저 읽어들이는 '컨텍스트 앵커'입니다. 이 파일에 '심플리시티' 디자인 원칙을 명시함으로써, AI가 생성하는 모든 코드가 일관된 스타일을 유지하도록 강제해야 합니다.15

**권장 CLAUDE.md 구성안:**

# **Project Context: Simplicity Design System Implementation**

이 프로젝트는 Toss의 'Simplicity' 디자인 언어를 Next.js 15, Tailwind CSS v4, Framer Motion으로 구현하는 고품질 웹 애플리케이션입니다.

## **1\. Design Principles (절대 준수)**

* **Typography First**: 모든 위계는 폰트 크기와 굵기(Pretendard)로만 표현한다. 불필요한 테두리(Border)나 장식 요소를 제거하라.  
* **Micro-Interaction**: 모든 버튼과 카드 요소는 클릭/터치 시 scale: 0.96의 스프링 애니메이션을 포함해야 한다.  
* **Spacing**: 4px 그리드 시스템을 엄격히 준수하되, 여백(Whitespace)을 과감하게 사용하여 콘텐츠를 구분한다.  
* **Roundness**: 카드와 버튼의 모서리 둥글기는 rounded-2xl (20px) 이상을 기본으로 하여 부드러운 인상을 준다.

## **2\. Tech Stack Constraints**

* **Framework**: Next.js 15 (App Router). 'use client' 지시어는 인터랙션이 필요한 리프(Leaf) 컴포넌트에만 최소한으로 사용한다.  
* **Styling**: Tailwind CSS. 색상은 bg-toss-blue, text-grey-700과 같이 커스텀 정의된 토큰만 사용한다 (Arbitrary value 금지).  
* **Motion**: framer-motion 라이브러리를 사용한다. 모든 트랜지션은 type: "spring"을 기본으로 한다.  
* **Database**: Supabase via MCP. 데이터 페칭은 서버 컴포넌트에서 수행한다.

## **3\. Workflow Rules**

* 새로운 컴포넌트 생성 시 반드시 모바일 뷰포트를 우선 고려한다 (Mobile-First).  
* 아이콘은 lucide-react를 사용하되, 선 두께(stroke-width)는 2px로 고정한다.  
  심층 분석: 위와 같이 구체적인 제약 조건을 명시함으로써, Claude가 범용적인 코드를 생성하는 '컨텍스트 드리프트(Context Drift)' 현상을 방지할 수 있습니다. 특히 "Arbitrary value 금지"와 같은 규칙은 디자인 시스템의 파편화를 막는 핵심 장치입니다.17

### **3.2 권한 관리 및 설정 최적화 (.claude/settings.json)**

디자인 시스템 구축 초기에는 수많은 패키지 설치(npm install)와 파일 생성이 필요합니다. Claude Code의 권한 시스템이 작업 흐름을 끊지 않도록 프로젝트 레벨의 설정을 최적화해야 합니다.

**프로젝트 설정 파일 (.claude/settings.json):**

JSON

{  
  "commands": {  
    "allow": \["npm", "npx", "git"\]  
  },  
  "autoCompact": true,  
  "contextSize": 100000  
}

* **commands.allow**: npm과 npx 명령어를 승인 목록에 추가하여, 패키지 설치나 Supabase 타입 생성 시 매번 승인 과정을 거치지 않도록 합니다.19  
* **autoCompact**: 긴 대화 맥락을 자동으로 요약하여 디자인 일관성을 잃지 않으면서도 토큰 비용을 관리합니다.

---

## **4\. 파운데이션 구현: 기술 스택 설정과 디자인 토큰화**

디자인 언어를 활용하는 첫 단계는 이를 코드로 '번역'하여 시스템화하는 것입니다. Next.js와 Tailwind CSS는 이 번역 과정을 가장 효율적으로 수행할 수 있는 도구입니다.

### **4.1 타이포그래피 엔지니어링: Pretendard와 next/font**

한글 폰트는 파일 용량이 크기 때문에 웹 폰트 로딩 시 깜빡임(FOIT)이나 글꼴 변경(FOUT) 현상이 발생하기 쉽습니다. 이는 '심플리시티'가 추구하는 매끄러운 경험을 저해합니다. Next.js의 next/font/local을 사용하여 폰트 파일을 최적화하고 호스팅해야 합니다.7

**구현 코드 (src/app/layout.tsx):**

TypeScript

import localFont from 'next/font/local';  
import './globals.css';

// 가변 폰트(Variable Font) 사용으로 용량 최적화 및 다양한 웨이트 지원  
const pretendard \= localFont({  
  src: '../public/fonts/PretendardVariable.woff2',  
  display: 'swap',  
  weight: '45 920', // Thin부터 Black까지 지원하는 가변 범위  
  variable: '--font-pretendard',  
});

export default function RootLayout({ children }: { children: React.ReactNode }) {  
  return (  
    \<html lang\="ko" className\={\`${pretendard.variable}\`}\>  
      {/\* 기본 배경색과 글자색을 디자인 토큰으로 지정하여 다크 모드 대응 준비 \*/}  
      \<body className\="font-sans antialiased bg-grey-100 text-grey-900"\>  
        {children}  
      \</body\>  
    \</html\>  
  );  
}

*기술적 통찰:* variable 속성을 사용하여 CSS 변수로 폰트를 주입하면, Tailwind 설정에서 이를 참조하기가 매우 용이해집니다. 이는 서버 사이드 렌더링(SSR) 시에도 폰트 스타일이 즉시 적용되도록 보장합니다.7

### **4.2 컬러 시스템의 토큰화: HSL 기반의 동적 제어**

'Toss Blue'와 같은 브랜드 컬러를 Tailwind 설정 파일에 하드코딩하는 것은 유연성을 떨어뜨립니다. 대신 CSS 변수(Variables)와 HSL 색상 모델을 사용하여 투명도(Alpha Channel) 조절이 가능한 유연한 토큰 시스템을 구축해야 합니다.8

**CSS 변수 정의 (src/styles/globals.css):**

CSS

@tailwind base;  
@tailwind components;  
@tailwind utilities;

@layer base {  
  :root {  
    /\* Toss Blue: 선명하고 신뢰감을 주는 파란색 \*/  
    /\* HSL: Hue 216, Saturation 100%, Lightness 50% \*/  
    \--toss-blue: 216 100% 50%;  
      
    /\* Cool Greys: 차가운 톤의 회색 스펙트럼 \*/  
    \--grey-50: 210 20% 98%;  /\* 배경색 \*/  
    \--grey-100: 210 20% 96%; /\* 카드 배경 \*/  
    \--grey-200: 210 16% 93%; /\* 비활성 요소 \*/  
    \--grey-300: 210 14% 89%; /\* 경계선 \*/  
    \--grey-500: 210 10% 56%; /\* 부가 설명 텍스트 \*/  
    \--grey-700: 210 12% 30%; /\* 본문 텍스트 \*/  
    \--grey-900: 210 14% 11%; /\* 제목 텍스트 \*/  
  }  
}

**Tailwind 설정 (tailwind.config.ts):**

TypeScript

import type { Config } from "tailwindcss";

const config: Config \= {  
  theme: {  
    extend: {  
      colors: {  
        // Tailwind의 Opacity Modifier 문법(\<alpha-value\>) 지원  
        toss: {  
          blue: "hsl(var(--toss-blue) / \<alpha-value\>)",  
        },  
        grey: {  
          50: "hsl(var(--grey-50) / \<alpha-value\>)",  
          100: "hsl(var(--grey-100) / \<alpha-value\>)",  
          //... (나머지 단계 매핑)  
          900: "hsl(var(--grey-900) / \<alpha-value\>)",  
        }  
      },  
      fontFamily: {  
        // Pretendard를 최우선 순위로 배치  
        sans: \["var(--font-pretendard)", "Pretendard", "-apple-system", "sans-serif"\],  
      }  
    }  
  }  
};  
export default config;

*전략적 의미:* 이렇게 설정하면 개발자는 bg-toss-blue/20과 같이 투명도가 적용된 배경색을 직관적으로 사용할 수 있습니다. 이는 버튼의 호버(Hover) 상태나 포커스 링(Ring)을 디자인할 때 "색상을 겹쳐 쌓는" 심플리시티 디자인의 깊이감 표현에 필수적입니다.23

---

## **5\. 인터랙션의 물리적 구현: Framer Motion 활용 전략**

'심플리시티' 디자인 언어는 시각적 단순함을 보완하기 위해 풍부한 '촉각적 피드백'을 제공합니다. 이를 웹에서 구현하기 위해 Framer Motion의 스프링 물리 엔진을 정교하게 튜닝해야 합니다.

### **5.1 네이티브 감각의 스프링(Spring) 상수 도출**

웹 애니메이션의 기본값인 베지어 곡선(Bezier Curve)은 시작과 끝이 정해진 시간 내에 움직이는 방식이라 부자연스럽게 느껴질 수 있습니다. 반면, 스프링 애니메이션은 물리적인 힘(Force)에 기반하여 움직이므로 훨씬 자연스럽습니다. iOS의 쫀득한 느낌을 재현하기 위한 '황금 비율' 설정값은 다음과 같습니다.12

| 파라미터 (Parameter) | 값 (Value) | 효과 및 설명 (Description) |
| :---- | :---- | :---- |
| **Stiffness (강성)** | 400 | 스프링의 뻣뻣한 정도. 높을수록 터치에 즉각적이고 빠르게 반응합니다. 모바일 앱과 같은 기민함을 줍니다. |
| **Damping (감쇠)** | 30 | 진동을 억제하는 힘. 이 값이 낮으면 띠용거리고(Oscillation), 높으면 뻑뻑합니다. 30 정도가 과도한 흔들림 없이 부드럽게 안착하는 최적점입니다. |
| **Mass (질량)** | 1 | 요소의 무게감. 기본값을 유지하여 표준적인 관성을 제공합니다. |

### **5.2 재사용 가능한 모션 훅(Hook) 개발**

모든 컴포넌트에서 설정을 반복하지 않도록, 커스텀 훅을 만들어 디자인 시스템의 일부로 배포합니다.

**src/hooks/use-toss-motion.ts:**

TypeScript

export const springTransition \= {  
  type: "spring",  
  stiffness: 400,  
  damping: 30,  
};

// 버튼 클릭 시 꾹 눌리는 효과  
export const tapAnimation \= {  
  scale: 0.96,  
  transition: { duration: 0.1 } // 클릭은 즉각적이어야 하므로 짧은 duration 사용  
};

// 리스트 아이템이 순차적으로 떠오르는 효과  
export const slideUpVariants \= {  
  hidden: { opacity: 0, y: 20 },  
  visible: (i: number) \=\> ({  
    opacity: 1,  
    y: 0,  
    transition: {  
      delay: i \* 0.05, // 0.05초 간격의 스태거링(Staggering)  
     ...springTransition  
    }  
  })  
};

### **5.3 레이아웃 애니메이션 (Magic Motion)**

토스 인터페이스의 특징 중 하나는 숫자가 바뀌거나 리스트 순서가 변경될 때 끊김 없이 부드럽게 위치가 이동하는 것입니다. Framer Motion의 layout 속성은 이를 코드 한 줄로 구현하게 해줍니다.25

TypeScript

\<motion.div layout className="bg-white rounded-2xl p-4"\>  
  {/\* 내용이 바뀌어 높이가 변하더라도 부드럽게 크기가 조절됨 \*/}  
\</motion.div\>

이 기능은 아코디언 메뉴나 탭 전환 시 콘텐츠 높이가 변할 때, 주변 요소들이 자연스럽게 밀려나는 효과를 구현하는 데 핵심적입니다.

---

## **6\. 데이터 기반 디자인: Supabase와 MCP의 통합**

디자인 언어는 정적인 화면에 그치지 않습니다. 실제 데이터가 흐를 때의 로딩 상태(Skeleton), 에러 상태, 데이터 없음(Empty State) 등의 처리가 UX의 완성도를 결정합니다. Supabase MCP(Model Context Protocol)를 활용하면 Claude가 데이터베이스 스키마를 이해하고 이에 맞는 UI 상태를 자동으로 설계할 수 있습니다.

### **6.1 Supabase MCP 서버 설정**

Claude가 프로젝트의 데이터 구조를 실시간으로 조회하고 마이그레이션을 수행할 수 있도록 MCP 서버를 연동합니다.26

**Claude 데스크탑 설정 (claude\_desktop\_config.json):**

JSON

{  
  "mcpServers": {  
    "supabase": {  
      "type": "http",  
      "url": "https://mcp.supabase.com/mcp?project\_ref=${SUPABASE\_PROJECT\_REF}",  
      "headers": {  
        "Authorization": "Bearer ${SUPABASE\_ACCESS\_TOKEN}"  
      }  
    }  
  }  
}

*활용 시나리오:*

1. **스키마 조회:** "현재 users 테이블의 컬럼 정보를 확인하고, 프로필 카드 컴포넌트에 필요한 TypeScript 인터페이스를 생성해줘."  
2. **데이터 시딩:** "UI 테스트를 위해 transactions 테이블에 다양한 상태(성공, 실패, 대기)의 더미 데이터를 10개 생성해줘."  
3. **마이그레이션:** "송금 메모 기능을 추가하려고 해. transactions 테이블에 memo 컬럼을 추가하는 마이그레이션 SQL을 작성하고 실행해줘."

### **6.2 실시간성(Real-time)의 시각화**

'심플리시티' UX는 사용자의 행동에 대한 피드백이 즉각적입니다. 송금이 완료되거나 알림이 올 때 페이지 새로고침 없이 UI가 반응해야 합니다. Supabase의 Realtime 기능을 framer-motion의 AnimatePresence와 결합하면 이를 구현할 수 있습니다.28

구현 패턴:  
Supabase의 on('postgres\_changes') 이벤트를 리스닝하여 상태를 업데이트하고, 해당 상태 변화가 Framer Motion의 initial, animate, exit 애니메이션을 트리거하도록 연결합니다. 이를 통해 새로운 알림이 올 때 상단에서 부드럽게 내려오는 토스트(Toast) 메시지 등을 구현할 수 있습니다.

---

## **7\. 종합 가이드: '최근 송금 목록' 기능 구현 시나리오**

지금까지 논의한 모든 요소(디자인 철학, 기술 스택, 에이전트 워크플로우)를 결합하여 실제 기능을 구현하는 과정을 단계별로 서술합니다.

### **Step 1: 에이전트 컨텍스트 주입**

Claude에게 디자인 시스템의 맥락을 인식시킵니다.

**Prompt:** "지금부터 토스 스타일의 '최근 송금 목록' 컴포넌트를 만들 거야. CLAUDE.md에 정의된 Typography 규칙과 Color Token을 확인해. 특히 아바타 이미지는 rounded-full을 사용하고, 이름은 text-grey-700, 금액은 text-grey-900에 font-bold를 적용해야 해."

### **Step 2: 데이터 레이어 설계 (MCP 활용)**

**Prompt:** "Supabase MCP를 사용하여 recent\_transfers 뷰(View)를 생성해줘. 이 뷰는 최근 거래 내역 중 중복되지 않는 수취인 목록을 최신순으로 10개 가져와야 해. 그리고 이에 맞는 TypeScript 타입을 types/supabase.ts에 정의해줘."

*Claude의 작업:* SQL 쿼리를 실행하여 뷰를 생성하고, 정확한 타입을 추출하여 프론트엔드 코드의 안정성을 확보합니다.

### **Step 3: 컴포넌트 스캐폴딩 및 스타일링**

**Prompt:** "가로 스크롤이 가능한 RecentTransferList 컴포넌트를 만들어줘. 각 아이템은 세로로 정렬된 아바타와 이름으로 구성돼. Tailwind를 사용하되, 스크롤바는 숨겨줘(scrollbar-hide). 각 아이템 사이의 간격은 16px로 설정해."

### **Step 4: 인터랙션 및 모션 주입**

**Prompt:** "이제 Framer Motion을 적용하자.

1. 리스트가 처음 로드될 때 왼쪽에서 오른쪽으로 순차적으로 나타나는 staggerChildren 효과를 적용해.  
2. 각 아이템을 터치하거나 클릭할 때 scale: 0.9로 줄어드는 탭 인터랙션을 추가해. 이때 우리가 정의한 springTransition 상수를 사용해."

### **Step 5: 에지 케이스(Edge Case) 처리**

**Prompt:** "송금 내역이 없는 경우(Empty State)를 처리해줘. 단순히 '없음' 글자만 띄우지 말고, 토스페이스 스타일의 아이콘(예: 돋보기나 웃는 얼굴)을 중앙에 배치하고, '첫 송금을 시작해보세요'라는 문구와 함께 bg-toss-blue 버튼을 렌더링해줘."

---

## **8\. 결론: 디자인 시스템의 지속 가능한 진화**

우리가 조사한 UI/UX 언어를 성공적으로 활용한다는 것은 단순히 시각적인 모방(Pixel Pushing)을 넘어서는 일입니다. 그것은 **'본질에 집중하는 철학(Simplicity)'**, **'물리적인 감각(Motion)'**, 그리고 \*\*'데이터의 흐름(Data)'\*\*을 하나의 유기적인 시스템으로 통합하는 엔지니어링 과정입니다.

본 보고서에서 제시한 기술적 방법론들—CLAUDE.md를 통한 엄격한 컨텍스트 제어, Tailwind 변수를 통한 디자인 토큰 시스템화, Framer Motion의 물리 엔진 튜닝, 그리고 Supabase MCP를 통한 데이터 통합—은 이 복잡한 과정을 효율화하는 핵심 열쇠입니다.

이러한 체계를 갖춤으로써, 개발팀은 반복적인 UI 작업에서 벗어나 "어떻게 하면 사용자의 금융 생활을 더 편하게 만들까?"라는 본질적인 문제 해결에 집중할 수 있게 됩니다. 이것이 바로 '심플리시티' 디자인 언어가 추구하는 궁극적인 목표이자, 에이전틱 디자인 엔지니어링이 제공하는 가치입니다.

---

## **9\. 부록: 핵심 구현 참조 코드**

### **A.1 시멘틱 컬러 및 폰트 설정 (Full Configuration)**

TypeScript

// tailwind.config.ts  
import type { Config } from "tailwindcss";

const config: Config \= {  
  // 다크 모드 지원을 위한 class 전략  
  darkMode: \["class"\],  
  content: \["./src/\*\*/\*.{ts,tsx}"\],  
  theme: {  
    extend: {  
      colors: {  
        background: "hsl(var(--grey-50))",  
        foreground: "hsl(var(--grey-900))",  
        toss: {  
          blue: {  
            DEFAULT: "hsl(var(--toss-blue))",  
            light: "hsl(var(--toss-blue-light))", // 버튼 배경 등으로 활용  
          },  
          grey: {  
             50: "\#F9FAFB",  
            100: "\#F2F4F6", // 카드 배경색 (가장 많이 사용됨)  
            300: "\#D1D6DB", // 옅은 구분선  
            500: "\#8B95A1", // 보조 텍스트  
            700: "\#4E5968", // 본문 텍스트  
            900: "\#191F28"  // 강조 텍스트 (타이틀)  
          }  
        },  
      },  
      borderRadius: {  
        '3xl': '24px', // 토스 스타일의 둥근 카드  
        '4xl': '32px', // 바텀 시트 상단 등  
      },  
      fontFamily: {  
        sans: \["var(--font-pretendard)", "sans-serif"\],  
      },  
      boxShadow: {  
        'toss-sm': '0 2px 8px rgba(0, 0, 0, 0.04)', // 매우 부드러운 그림자  
        'toss-md': '0 8px 24px rgba(0, 0, 0, 0.08)', // 플로팅 요소 그림자  
      }  
    },  
  },  
  plugins:,  
};  
export default config;

### **A.2 토스 스타일 카드 컴포넌트 (Interactive Component)**

TypeScript

// src/components/TossCard.tsx  
import { motion } from "framer-motion";  
import { springTransition, tapAnimation } from "@/hooks/use-toss-motion";

interface TossCardProps {  
  title: string;  
  amount: string;  
  icon?: React.ReactNode;  
}

export function TossCard({ title, amount, icon }: TossCardProps) {  
  return (  
    \<motion.div  
      // 1\. 레이아웃 애니메이션 활성화  
      layout  
      // 2\. 탭 인터랙션 적용  
      whileTap={tapAnimation}  
      // 3\. 스프링 물리 적용  
      transition={springTransition}  
      className="bg-white p-6 rounded-3xl shadow-toss-sm flex justify-between items-center cursor-pointer w-full mb-4 active:bg-grey-50"  
    \>  
      \<div className="flex flex-col gap-1"\>  
        {/\* 위계 구조: 타이틀은 회색, 금액은 진한색+Bold \*/}  
        \<span className="text-toss-grey-500 font-medium text-sm"\>{title}\</span\>  
        \<span className="text-toss-grey-900 font-bold text-2xl tracking-tight"\>{amount}\</span\>  
      \</div\>  
      {icon && (  
        \<div className="text-toss-blue bg-toss-blue-light p-3 rounded-full"\>  
          {icon}  
        \</div\>  
      )}  
    \</motion.div\>  
  );  
}

#### **참고 자료**

1. 1월 1, 1970에 액세스, [https://toss.tech/article/simplicity-21-recap](https://toss.tech/article/simplicity-21-recap)  
2. Integrating Motion Graphics into Web Apps | News \- Essential Designs, 12월 1, 2025에 액세스, [https://www.essentialdesigns.net/news/integrating-motion-graphics-into-web-apps](https://www.essentialdesigns.net/news/integrating-motion-graphics-into-web-apps)  
3. Which CTA Button Color Converts the Best? \- CXL, 12월 1, 2025에 액세스, [https://cxl.com/blog/which-color-converts-the-best/](https://cxl.com/blog/which-color-converts-the-best/)  
4. Claude Code overview \- Claude Code Docs, 12월 1, 2025에 액세스, [https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview](https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview)  
5. Claude Code Learning Path: a practical guide to getting started | by Daniel Avila | Oct, 2025, 12월 1, 2025에 액세스, [https://medium.com/@dan.avila7/claude-code-learning-path-a-practical-guide-to-getting-started-fcc601550476](https://medium.com/@dan.avila7/claude-code-learning-path-a-practical-guide-to-getting-started-fcc601550476)  
6. Custom local font works locally in Next.js but not on Vercel deployment \- Stack Overflow, 12월 1, 2025에 액세스, [https://stackoverflow.com/questions/79550919/custom-local-font-works-locally-in-next-js-but-not-on-vercel-deployment](https://stackoverflow.com/questions/79550919/custom-local-font-works-locally-in-next-js-but-not-on-vercel-deployment)  
7. How to Use Custom Fonts in Next.js with Tailwind CSS — The Clean Way \- Medium, 12월 1, 2025에 액세스, [https://medium.com/@youness.jabar.pro/how-to-use-custom-fonts-in-next-js-with-tailwind-css-the-clean-way-6a82f0a4781f](https://medium.com/@youness.jabar.pro/how-to-use-custom-fonts-in-next-js-with-tailwind-css-the-clean-way-6a82f0a4781f)  
8. Colors \- Core concepts \- Tailwind CSS, 12월 1, 2025에 액세스, [https://tailwindcss.com/docs/customizing-colors](https://tailwindcss.com/docs/customizing-colors)  
9. Naming Scales; Colour properties in a design system (opacity, shades, etc) \- Reddit, 12월 1, 2025에 액세스, [https://www.reddit.com/r/Design/comments/1e9rcwz/naming\_scales\_colour\_properties\_in\_a\_design/](https://www.reddit.com/r/Design/comments/1e9rcwz/naming_scales_colour_properties_in_a_design/)  
10. Decoding the Art of Color Palettes for Scalable Design Systems | by Rohan Kamath, 12월 1, 2025에 액세스, [https://blog.kamathrohan.com/decoding-the-art-of-color-palettes-for-scalable-design-systems-e77a3cc8d3de](https://blog.kamathrohan.com/decoding-the-art-of-color-palettes-for-scalable-design-systems-e77a3cc8d3de)  
11. Advanced animation patterns with Framer Motion \- The Blog of Maxime Heckel, 12월 1, 2025에 액세스, [https://blog.maximeheckel.com/posts/advanced-animation-patterns-with-framer-motion/](https://blog.maximeheckel.com/posts/advanced-animation-patterns-with-framer-motion/)  
12. React transitions — Configure Motion animations, 12월 1, 2025에 액세스, [https://motion.dev/docs/react-transitions](https://motion.dev/docs/react-transitions)  
13. Claude Code Programming Tutorial for Beginners (Step-by-Step), 12월 1, 2025에 액세스, [https://www.youtube.com/watch?v=hewApCHwXh0](https://www.youtube.com/watch?v=hewApCHwXh0)  
14. Claude Code on the web \- Claude Code Docs, 12월 1, 2025에 액세스, [https://code.claude.com/docs/en/claude-code-on-the-web](https://code.claude.com/docs/en/claude-code-on-the-web)  
15. Using CLAUDE.MD files: Customizing Claude Code for your codebase, 12월 1, 2025에 액세스, [https://www.claude.com/blog/using-claude-md-files](https://www.claude.com/blog/using-claude-md-files)  
16. Claude Code: Best practices for agentic coding \- Anthropic, 12월 1, 2025에 액세스, [https://www.anthropic.com/engineering/claude-code-best-practices](https://www.anthropic.com/engineering/claude-code-best-practices)  
17. How to get Claude Code CLI to stick to what is written in CLAUDE.md, 12월 1, 2025에 액세스, [https://www.reddit.com/r/ClaudeAI/comments/1p8t6ig/how\_to\_get\_claude\_code\_cli\_to\_stick\_to\_what\_is/](https://www.reddit.com/r/ClaudeAI/comments/1p8t6ig/how_to_get_claude_code_cli_to_stick_to_what_is/)  
18. The Complete Guide to Setting Global Instructions for Claude Code CLI \- Naqeeb ali Shamsi, 12월 1, 2025에 액세스, [https://naqeebali-shamsi.medium.com/the-complete-guide-to-setting-global-instructions-for-claude-code-cli-cec8407c99a0](https://naqeebali-shamsi.medium.com/the-complete-guide-to-setting-global-instructions-for-claude-code-cli-cec8407c99a0)  
19. Claude Code settings.json : r/ClaudeAI \- Reddit, 12월 1, 2025에 액세스, [https://www.reddit.com/r/ClaudeAI/comments/1l24a93/claude\_code\_settingsjson/](https://www.reddit.com/r/ClaudeAI/comments/1l24a93/claude_code_settingsjson/)  
20. feiskyer/claude-code-settings: Claude Code settings, commands and agents for vibe coding, 12월 1, 2025에 액세스, [https://github.com/feiskyer/claude-code-settings](https://github.com/feiskyer/claude-code-settings)  
21. Getting Started: Font Optimization \- Next.js, 12월 1, 2025에 액세스, [https://nextjs.org/docs/app/getting-started/fonts](https://nextjs.org/docs/app/getting-started/fonts)  
22. Components: Font | Next.js, 12월 1, 2025에 액세스, [https://nextjs.org/docs/pages/api-reference/components/font](https://nextjs.org/docs/pages/api-reference/components/font)  
23. Day 8: How to Add Custom Shadows and Depth in Tailwind CSS \- DEV Community, 12월 1, 2025에 액세스, [https://dev.to/ruqaiya\_beguwala/day-8-how-to-add-custom-shadows-and-depth-in-tailwind-css-jag](https://dev.to/ruqaiya_beguwala/day-8-how-to-add-custom-shadows-and-depth-in-tailwind-css-jag)  
24. Fine-Tune Your Motion Animations with the Spring Visualizer \- YouTube, 12월 1, 2025에 액세스, [https://www.youtube.com/watch?v=pgCwGAhvUg4](https://www.youtube.com/watch?v=pgCwGAhvUg4)  
25. Layout Animation — React FLIP & Shared Element \- Motion, 12월 1, 2025에 액세스, [https://motion.dev/docs/react-layout-animations](https://motion.dev/docs/react-layout-animations)  
26. supabase-community/supabase-mcp: Connect Supabase ... \- GitHub, 12월 1, 2025에 액세스, [https://github.com/supabase-community/supabase-mcp](https://github.com/supabase-community/supabase-mcp)  
27. Model context protocol (MCP) | Supabase Docs, 12월 1, 2025에 액세스, [https://supabase.com/docs/guides/getting-started/mcp](https://supabase.com/docs/guides/getting-started/mcp)  
28. Exploring Supabase's Advanced Capabilities: Model Context Protocol, CLI, and Edge Functions | by Vignaraj Ravi | Oct, 2025 | Medium, 12월 1, 2025에 액세스, [https://medium.com/@vignarajj/exploring-supabases-advanced-capabilities-model-context-protocol-cli-and-edge-functions-37a1ce4771d4](https://medium.com/@vignarajj/exploring-supabases-advanced-capabilities-model-context-protocol-cli-and-edge-functions-37a1ce4771d4)